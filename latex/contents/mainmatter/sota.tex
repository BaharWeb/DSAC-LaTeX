\hypertarget{sec:sota}{%
\chapter{State of the Art}\label{sec:sota}}

This chapter provides an overview and comparison of the state-of-the-art methods and approaches, addressing the aforementioned problems. The main focus of this review is on the \gls{eud} solutions. The criteria for selecting approaches and technologies revolves around their relevance and alignment with the main objectives defined earlier. As outlined in \cref{sec:requirements-analysis}, the final tool should satisfy two sets of requirements: Process requirements and Tool requirements. In this chapter, we review the state-of-the-art research based on these requirements.  Among the existing solutions proposed for developing situational decision-making tools for domain experts, we start with \gls{eud} methods and categorizing existing solutions from various angles. Subsequently, we continue with the Web Composition tools, Model-Driven and Ontology-based development approaches. The evaluation process is based on the assessment schema introduced in \cref{sec:requirements-analysis} guided by the identified requirements.


\vspace{-15pt}
\hypertarget{end-user-development}{%
\section{End User Development}\label{sec:end-user-development}}
\vspace{15pt}

End-user development emerged as a solution to address interaction challenges between human and computer. For more than three decades researchers have been studied the approaches and techniques to shift the development process more towards the end users. At the same time, with technical advancements, socio-cultural shifts promoted end-users' participation in the software development. These transformations led to a change in roles, emphasizing the significance of \gls{eud} research as users transitioned into more active developer roles \autocite{Santos2019}. Moreover, the number of end users with domain expertise is increasing. According to a worldwide study presented in \autocite{Mackowiak2018} there are 7.5 million non-programmer end users in addition to 11 million professional programmers. Therefore, the need to foster the \gls{eud} methods for efficient end-user's involvement is evident.

The primary motivation for \gls{eud} practices is the miscommunication during requirement analysis, which is caused by the programmers' lack of domain expertise. Moreover, conventional software development techniques face challenges in coping with rapidly changing user requirements. These approaches are particularly inefficient for addressing the one-time situational needs \autocite{Paterno2013}. In an early study done by \autocite{Henderson1995}, the characteristics of a reasonable \gls{eud} solution were identified as the adaptability to changes within a target domain and consideration for real-world unpredictability. For developing an efficient \gls{eud} tool, it is essential to bear in mind that the tool should not burden the end users with technology-related programming tasks to guarantee a reasonable level of usability \autocite{Paterno2017a}.

With the growing interest in end users' involvement in the design and development process, distinct research directions have emerged. Two related fields are End-User Programming (EUP) and End-User Software Engineering (EUSE) \autocite{Barbosa2017}. The EUP is a subset of \gls{eud} with a dedicated focus on creating programs and writing code to achieve final goal. EUP approaches foster domain-specific programming languages and techniques, such as visual programming or programming by demonstration \autocite{Barricelli2019}. A key difference between \gls{eud} and EUP lies in the range of covered phases. \gls{eud} methods covers the entire development lifecycle while EUP only focuses on the creation phase \autocite{Santos2019}. Another related research field is EUSE, compared to \gls{eud} and EUP, it has a dedicated emphasis on the methods and techniques that guarantee the quality of the designed software \autocite{Barricelli2019}. In this work the main focus is on the \gls{eud} practices since it covers the wide range of methods and techniques.

\gls{eud} techniques are usually prototype-based and consist of several iterations. In such practices, the focus is mainly on solving the situational problem addressed by the end-user rather than the developed tool itself \autocite{Rosson2007}. Studies demonstrated that end-users often tend to apply try-and-error methods rather than following the conventional development process including planning, designing, coding, and testing. End-users' participation is typically limited to the implementation phase, as they lack sufficient technical skills for planning and testing phases \autocite{Tschudnowsky2016}.

\vspace{-10pt}
\hypertarget{sec:eud-approaches}{%
\subsection{EUD Approach Categories }\label{sec:eud-approaches}}
\vspace{10pt}

To comprehensively review state-of-the-art studies in the \gls{eud} domain, we first categorize existing work based on four key dimensions that serve as the foundation for classifying approaches. At the end of this section, a number of influential studies in this domain are presented and reviewed accordingly.

\hypertarget{edu-domain}{%
\subsubsection*{\gls{eud} Application Domain}\label{edu-domain}}
According to \autocite{Maceli2017} the \gls{eud} approaches can be classified into thirteen categories based on their application domains. In a separate study conducted by \autocite{Barricelli2019} the three domains with the highest frequency are “business and data management” at 24\%, “web applications and mashups” at 23\%, and “smart objects and smart environments” at 16\%. 
To further identify the solution categories in \gls{eud} research, we applied the \gls{lda} algorithm to discover the latent topics in \gls{eud} publications. \gls{lda} is a topic modeling technique used to unveil the thematic structures of texts without depending on predefined keywords. We applied the \gls{lda} algorithm on a corpus comprising 60 papers published from 1998 to 2020. The selection criteria were based on the relevance of the titles and keywords to the \gls{eud} topics. The Gensim \footnote{\url{https://radimrehurek.com/gensim/models/ldamodel.html}}   python library is used to train the \gls{lda} model with topic number of five. The following table presents the result of topic modeling process. Later, we classified reviewed publications under the mentioned categories. 

\hypertarget{tbl:edu-topics}{}
\begin{longtable}{@{}lllll@{}}
\caption{\label{tbl:edu-topics}Top five most used terms for each identified EUD topic}\tabularnewline
\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 1\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 2\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 3\strut
\end{minipage} & 
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Topic 4\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 5\strut
\end{minipage} \tabularnewline
\midrule
\endfirsthead

\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 1\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 2\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 3\strut
\end{minipage} & 
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Topic 4\strut
\end{minipage} & 
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Topic 5\strut
\end{minipage} \tabularnewline
\midrule
\endhead

Task & Business & Web & Mashup & Service \tabularnewline
Model & Source & Domain & Component & Device \tabularnewline
Domain & Database & Ontology & Service & \gls{iot} \tabularnewline
Language & Service & \gls{nlp} & Composition & Mobile \tabularnewline
Concept & Query & Language & Language & HCI \tabularnewline

\bottomrule
\end{longtable}

Based on presented result in \cref{tbl:edu-topics}, the top five identified topics in \gls{eud} research domains are as follows: programming tools, business and data management, semantic technique, Web application and mashups, and \gls{iot} or smart objects. 

\hypertarget{edu-technique}{%
\subsubsection*{\gls{eud} Technique}\label{edu-technique}}
Another aspect for analyzing state-of-the-art  approaches in \gls{lda} field, involves examining the techniques employed during the implementation phase to create or modify the software artifacts. A solution may use a single technique or a combination of several. This section briefly introduces a number of the most common techniques. 

\emph{Component-based} approaches are originated in software engineering practices to tackle complexity and compatibility issues as well as security challenges of traditional software development processes. In this technique, the software is built by composing separate, independent modules known as components. A component is defined as a “reusable software elements generated based on a meta-model, that can be deployed or modified independent from other software elements”. Components are encapsulated according to their functionalities, and they may reuse existing prewritten code. Many strategies and methods have been proposed to foster Component-based development in software and web applications. Pioneering companies, such as Microsoft, adopted this technique in their technologies, including \gls{com} and .NET \autocite{Tschudnowsky2016}.
According to \autocite{Barricelli2019} the component-based technique is the most frequent method in EUD solutions specially mashup environment. The reason lies in the offered advantages by this technique such as extendibility, reusability, and compatibility. 

\emph{Spreadsheets}, as one of the earliest successful examples of \gls{eud}, enable users to manage, modify, and present complex data. While the simplicity and high expressive power make this technique advantageous in \gls{eud} particularly mashup solutions, a notable drawback is its limited support for User Interface design.

\emph{Rule-based techniques} empower end-users, particularly domain experts, to dynamically customize solutions based on the condition and their experience. It offers a high level of flexibility as capturing and modifying rules are easy task for domain experts. Rules can be defined for various phases, including API or service aggregation and interface design \autocite{Pascalau2009}. The rule-based techniques are largely investigated in the domain of \gls{iot} and smart environments to personalize smart devices. The customization can be performed through a set of trigger-action rules. Rule-based solutions typically offers limited scalability and limited generalization. Scaling up the rule-based solutions can be a difficult task for end-users \autocite{Barricelli2019}.

\emph{Natural Language Programming} technique offers end-users
a communication medium based on a constrained natural language to adjust
system functionalities and behavior according to the
end-users' intentions \autocite{Myers2004}. At the
interface level, using natural language provides a high level of
expressiveness and eliminates unnecessary learning burdens \autocite{Tam1998}.

Due to recent advancements in natural language understanding methods as
seen in technologies such as Apple Siri and Google Assistant, the
\gls{nl}-based technique gained increasing popularity \autocite{Barricelli2019}. However, in most existing NL-based \gls{eud} solutions, end-users
are forced to communicate using a restricted language to reduce the
effort required for linguistic analysis. This causes an unwanted
learning burden and a lower expressiveness. Another unavoidable
limitation of this technique is the ambiguity inherent in natural
language processing algorithms \autocite{Paterno2013}.

Using Semantic parsers to transform natural language descriptions into
appropriate commands has gained research attention recently. This
technique aims to free up end-users from formal construction of commands
and bridge the gap between the user's input and the resulting command.
It has applications in different \gls{eud}-related fields such as robotics,
application control, and mobile applications \autocite{Sales2018}. Semantic parsers eliminate the ambiguity of natural language by
capturing the user's main intention semantically and turn it to a
machine-readable representation based on the user's defined syntax for
example only responding to queries in the form of  \gls{sql} or a third-party
 \gls{api} \autocite{Liang2015}.

\emph{\gls{pbd}} records the user's
behavior while working on concrete examples and then infers a general
model to apply to the same data in the same context \autocite{Aghaee2014}. The degree to which \gls{pbd} tools deduce the program varies
from one solution to another. Some solutions can infer the entire
program autonomously, while some requires end-user's involvement.
Therefore, the level of automation in PbD technique ranges from fully
automatic to semi-automatic. PbD approaches are typically combined with
visual programming \autocite{Paterno2013}. One potential drawback of this
approach is the complexity of modifying the inferred algorithm for
non-programmers \autocite{Tschudnowsky2016}.

\emph{\gls{wysiwyg}}~technique is a
form of live programming enabling end-users to instantiate solutions at
runtime using an editor. In these solutions, each component is presented
by an interface reflecting its behavior. \gls{wysiwyg} enhances the
tool’s directness and provides more intuitive user
interfaces. This approach is well-suited for applications at the
interface level but exhibits low performance for enterprise-level data
integration \autocite{Daniel2014}.

\emph{Visual programming} attracts attention in the \gls{eud} research field
for its high abstraction level \autocite{Aghaee2014}. In this approach,
technical concepts are presented to end users through graphical symbols.
This technique doesn't impose any learning burden for end-users so
unlike text-based programming users do not need to learn new syntax
\autocite{BURNETT2001}. However, visual programming approaches suffer from
scalability issues \autocite{Paterno2013}.

The implementation technique significantly affects both the usability
and expressiveness of the mashup solution \autocite{Barricelli2019}. The highest level of expressiveness is offered by NL-based and
visual programming techniques. On the other hand, the tool's usability
is influenced by the level of abstraction the technique provides.
Techniques characterized by high levels of abstraction such as PbD and
\gls{wysiwyg}, tend to offer higher usability for end-users \autocite{Aghaee2014}.
Mashup solutions can use more than one technique to guarantee a reasonable
level of usability and expressive power. The following table provides a
performance evaluation of these techniques regarding usability and
expressive power \autocite{Aghaee2014, Aghaee2014a}.

\hypertarget{tbl:edu-techniques}{}
\begin{longtable}{@{}lll@{}}
\caption{\label{tbl:eud-techniques}EUD Technique Analysis of Usability and Expressive Power}\tabularnewline
\toprule
\begin{minipage}[b]{0.30\columnwidth}\raggedright
EUD Technique\strut
\end{minipage} & 
\begin{minipage}[b]{0.30\columnwidth}\raggedright
Usability\strut
\end{minipage} & 
\begin{minipage}[b]{0.38\columnwidth}\raggedright
Expressive Power\strut
\end{minipage} \tabularnewline
\midrule
\endfirsthead

\toprule
\begin{minipage}[b]{0.30\columnwidth}\raggedright
EUD Technique\strut
\end{minipage} & 
\begin{minipage}[b]{0.30\columnwidth}\raggedright
Usability\strut
\end{minipage} & 
\begin{minipage}[b]{0.38\columnwidth}\raggedright
Expressive Power\strut
\end{minipage} \tabularnewline
\midrule
\endhead

Component-based & Medium-High & Dependent \tabularnewline
Spreadsheets & Medium-High & Low \tabularnewline
Rule-based & Medium-High & Low-Medium \tabularnewline
\gls{nl}-based & High & High \tabularnewline
\gls{pbd} & High & Low \tabularnewline
Visual Programming & Low-Medium & Medium-High \tabularnewline
\gls{wysiwyg} & High & Low \tabularnewline

\bottomrule
\end{longtable}

\hypertarget{user-domain}{%
\subsubsection*{User’s Domain}\label{user-domain}}
This dimension defines the target users of the EUD tool. All users are
considered non-programmers and categorized according to their domain
knowledge. In this classification, users are divided into generic users
and domain experts. Generic users only use EUD solutions to address
their daily general needs such as holiday planning. Most EUD solutions
are classified in this category \autocite{Santos2019}. General
purpose solutions are mainly focused on solution feasibility rather than
domain customization. According to a survey done by \autocite{Barricelli2019}, out of 165 reviewed papers in the EUD field, 64 specifically
targeted domain experts from various domains such as teachers,
therapists, civil engineers, etc.
The following table summarizes the number of selected EUD tools with respect
to the defined categorization factors. The complete review summary can
be found in the Appendix \cref{tbl:app.eud-practices}. The selection criteria for research works were
based on the citation number.

\hypertarget{tbl:eud-assessment}{}
\begin{longtable}{@{}lcccccccccccc@{}}
\caption{\label{tbl:eud-practices}Assessment of EUD Practices based on the Defined Categories}\tabularnewline
\toprule
\textbf{} & 
\rotatebox{90}{\textbf{faceMashup}} & 
\rotatebox{90}{\textbf{SemEval}} & 
\rotatebox{90}{\textbf{NaturalMash}} & 
\rotatebox{90}{\textbf{CRUISe}} & 
\rotatebox{90}{\textbf{Sales et al. (2018)}} & 
\rotatebox{90}{\textbf{HuRIC}} & 
\rotatebox{90}{\textbf{IFTTT}} & 
\rotatebox{90}{\textbf{MashArt}} & 
\rotatebox{90}{\textbf{OMMELET}} & 
\rotatebox{90}{\textbf{GOWDA}} & 
\rotatebox{90}{\textbf{Macías and Castells (2007)}} \tabularnewline
\midrule
\endfirsthead

\toprule
\textbf{} & 
\rotatebox{90}{\textbf{faceMashup}} & 
\rotatebox{90}{\textbf{SemEval}} & 
\rotatebox{90}{\textbf{NaturalMash}} & 
\rotatebox{90}{\textbf{CRUISe}} & 
\rotatebox{90}{\textbf{Sales et al. (2018)}} & 
\rotatebox{90}{\textbf{HuRIC}} & 
\rotatebox{90}{\textbf{IFTTT}} & 
\rotatebox{90}{\textbf{MashArt}} & 
\rotatebox{90}{\textbf{OMMELET}} & 
\rotatebox{90}{\textbf{GOWDA}} & 
\rotatebox{90}{\textbf{Macías and Castells (2007)}} \tabularnewline
\midrule
\endhead

\bottomrule
\endlastfoot

\multicolumn{12}{l}{\textbf{EUP Technique}} \tabularnewline
\midrule
Spreadsheets & & & & X & & & & X & & & \tabularnewline
\gls{pbd} & & & & & & & & & & & X \tabularnewline
VP & & & & & & & & X & & & \tabularnewline
\gls{wysiwyg} & X & & X & X & & & & & X & & X \tabularnewline
\gls{nlp} & & X & X & & & X & X & & & X & \tabularnewline
\gls{cbd} & & & & & X & & & & & & \tabularnewline
Rule-based & & & & & & & & & & & \tabularnewline

\midrule
\multicolumn{12}{l}{\textbf{Application Domain}} \tabularnewline
\midrule
WP & & & & & & & X & X & & & X \tabularnewline
Web and Data & & & & & & & & & & X & \tabularnewline
Mashup & X & & X & X & & & X & X & X & & \tabularnewline
Semantic & & X & & & & X & X & & & X & X \tabularnewline
\gls{iot} & & & & & X & & X & & & & \tabularnewline

\midrule
\multicolumn{12}{l}{\textbf{User's Domain}} \tabularnewline
\midrule
DS & & & & & & X & & & X & & \tabularnewline
General & X & & X & X & X & & & X & & & X \tabularnewline
Hybrid & & X & & & & & X & & & X & \tabularnewline

\end{longtable}


\vspace{-15pt}
\hypertarget{sec:wct}{%
\section{Web Composition Tools}\label{sec:wct}}

By applying the principles of Component-based Development, the
composition tool is an application with integrated logic by
orchestrating multiple building blocks known as components. In this
section, composition tools are thoroughly reviewed starting with the
early advancements in web service development.

Advancements in \gls{soa} have introduced new
approaches for software development by leveraging the concept of
decomposing software into loosely coupled functionality units known as
"services". Complex business processes can then be achieved by composing
services either during development time or runtime \autocite{Tschudnowsky2016}. The \gls{soa} paradigm promoted interoperability among applications and
offered a huge number of distributed services, which eventually led to
\gls{wsa}. At the same time, the advent of \gls{saas} within the cloud computing paradigm transformed the
application distribution \autocite{Daniel2014}.

A web service in WSA is defined as a self-contained application logic that
is accessible via the internet and can be invoked by standard web
technologies like \gls{http} or \gls{soap}. Following the WSA, web services are
composable to provide complex business logic \autocite{Yang2002a}. \gls{soap} and \gls{rest}ful services are two major types of web service
technologies. \gls{rest}ful services provide a collection of endpoints that
support HTTP operations (GET, POST, DELETE, and PUT), whereas \gls{soap}
services can be stateful with only one endpoint for a set of operations \autocite{Daniel2014}. In recent years, the \gls{rest}ful Application
\gls{api}s has gained increasing popularity due to
its flexibility and lightweight nature. They also do not require
XML-based description protocols such as WSDL or WADL. According to
\autocite{Zhang2019}, as of 2016, 84\% of registered web services
(over 14,800) on ProgrammableWeb were \gls{rest}ful web \gls{api}s, and the number
continues to grow \autocite{Zhang2020}.

The proliferation of web APIs as reusable \gls{Software Component}s accessible
on the internet, along with their extensive adaptation in modern
software development, accelerated the widespread adoption of web \gls{api}
mashups \autocite{Xue2017}. Web mashups emerged as a successful
example of a composition tool to address end-users' situational needs by
providing an additional functionality layer by
composing components \autocite{Tschudnowsky2016}.

According to \autocite{Daniel2014}, a web mashup is a composite
application comprising reusable components, including data, application
logic, or \gls{ui}. Mashups are characterized by a high level of reusability,
low development cost in terms of both cost and effort, and a lightweight
nature. A mashup tool/platform provides a development environment that
allows end users to design and develop their mashup and execute it in
the provided runtime environment that is typically available online as
a hosted service \autocite{Soi2014a}. Their operations adhere to
an internal logic, known as \emph{mashup logic}, which controls component
selection, composition patterns, data transformation and flow, as well as
the mashup tool interface. Designing a viable logic has attracted the most
attention in the mashup research field. In addition to the mentioned
dimensions for \gls{eud} tools, mashups can be reviewed from the following
two perspectives.


\vspace{-15pt}
\hypertarget{sec:mashup-style}{%
\subsection{Mashup Development Style}\label{sec:mashup-style}}
\vspace{15pt}

Depending on the domain and end-user’s expertise level, mashup development can fall into two development scenarios: centralized and participatory development. In centralized development, the mashup logic and architecture are designed by \gls{it} professionals, who then develop the final tool centrally. End users have minimal involvement in the development process and primarily serve as consumers of the completed application. This development style mainly sites the non-experts end user’s (hobby users). Participatory development, on the other hand, leveraging the end user’s domain expertise to perform tasks such as service selection and component composition based on domain-specific needs. Expert developers are responsible for component creation and programming of the tool \autocite{Daniel2014}.

\vspace{-10pt}
\hypertarget{sec:mashup-class}{%
\subsection{Mashup Classes}\label{sec:mashup-class}}
\vspace{10pt}

Depending on the component integration layer,  mashup tools are mainly categorized as Data Mashup, Logic Mashup, \gls{ui} Mashup or Hybrid Mashup. The mashup type is not directly related to the component type itself although the same logic is used to categorize the components as well.


\textbf{Data Mashups} fetch, process, and integrate data from different
heterogeneous data sources on the web, such as web services. The output
is a unified result set of data. Data mashups are typically presented in
the form of \gls{rss} feeds or \gls{rest}ful Web services \autocite{Aghaee2014}.

\textbf{Logic Mashups} operate at the application logic layer. Logic
mashups are responsible for defining component orchestration and
providing functionalities at any layer of data or logic \autocite{Daniel2014a}.

\textbf{UI Mashups} reside on the presentation layer and integrate the
components' user interfaces into one unified UI. A pure \gls{ui} mashup
normally uses a template with a placeholder for each component's user
interface. A key characteristic of this type of mashup is using the
publish/subscribe infrastructure to implement event-based UI
synchronization, allowing end users to have smooth interactions \autocite{Soi2014a}.

\textbf{Semantic Mashups} are built upon semantically annotated APIs and
are mainly created by applying semantic web techniques and using
semantic annotations such as \gls{rdf} or \gls{owl} \autocite{Malki2012}.
Semantic mashups are able to produce more meaningful results using
semantic web techniques such as information extraction, semantic mark-up
and annotation, or speech recognition.

\textbf{Hybrid Mashups} use various types of components and integrate
them at multiple levels. The main challenge here is cross-layer
integration since each layer has fundamentally different concerns than
other layers.

\hypertarget{sec:mdd}{%
\section{Model-Driven Development}\label{sec:mdd}}

\gls{mdd} is another approach that can be fostered to assist domain experts in developing situational decision-support tools. \gls{mdd} is a software development approach that aims to generate artifacts based on a formal specification known as a model. Models abstract the functionality of the application and can be used for generating source code or deriving other models, which makes them a suitable choice for creating software artifacts even for non-technical end-users \autocite{Dorodnykh2021}. In 2001, the \gls{omg} introduced \gls{mda} as a standard framework for leveraging models in software development. According to the \gls{omg}, \gls{mda} standardization document, the model is defined as an abstract, formal description of a system, presented with a graphical notation such as UML and formulated in \gls{xml} syntax. Models are instances of an upper class known as a metamodel, which specifies how to construct models \autocite{Haav2018}. Another principle in \gls{mdd} is the concept of model transformation, which is the manual or automated process of generating more specialized target models from existing source models. The target models conform to a set of transformation rules that describe the correspondence between elements of source and target models \autocite{Dorodnykh2021}.

\gls{mdd} approaches follow the same phases as in software development. The first engineering phase is the elicitation of the functional and non-functional requirements, also called the requirement analysis process. The requirements are in textual format and are formalized into a \gls{pim}. This model ignores the architectural design factors and implementation aspects. \gls{pim} is later mapped into a so-called \gls{psm}, describing the behavior and structure of the envisioned platform. The \gls{psm} is mapped into concrete code structures during the coding phase. The \gls{pim}-to-\gls{psm} and \gls{psm}-to-code mappings are done by performing automatic model-to-model and model-to-code transformations \autocite{Tschudnowsky2016}.

Many \gls{mdd} approaches are presented based on the target application class. The following are a number of the most commonly adopted approaches.

\textbf{\gls{dsm}} is characterized by abstracting a
model based on domain-specific concepts, rules, and semantics. \gls{dsm}
primarily involves two phases: in the abstraction phase, the solution is
specified using a domain-specific language that employs familiar
concepts and rules of the particular domain. During the coding phase,
the final product is generated in the preferred programming language.
This approach bridges the gap between domain concepts and the
implemented product \autocite{Lethrech2016}.

\textbf{\gls{dsl}} are programming languages
tailored to a particular problem domain. Examples of \gls{dsl}s include \gls{sql}
and LaTeX, which, unlike general-purpose languages such as Java or C\#,
are designed to focus solely on executing specifications within a
particular domain \autocite{Ceh2010}. Leveraging \gls{dsl}s can enhance
the application usability for domain experts and offer semantic
reusability. However, many existing practices in this domain still
primarily target developers. Other drawbacks of this approach include
high design and maintenance costs as well as scope definition
difficulty. In certain domains, such as database design, \gls{dsl}s
demonstrate improved performance when combined with other methods such
as visual programming. \gls{bpmn}
stands as another example of \gls{dsl} within the domain of business \autocite{Imran2013}.

\textbf{\gls{webml}} is one of the \gls{mdd} practices in
the field of Web Engineering. WebML provides a graphical notation and
methodology for web application development. The development process
entails several iterations, each capable of delivering a partially
developed web application by the end of its cycle. The data schema in
these applications is defined using Entity-Relationship diagrams. An
example of a successful \gls{webml}-based tool is the Java-based
WebRatio\footnote{\url{http://www.webratio.com/}} \autocite{Tschudnowsky2016}.


\hypertarget{ontology-driven-dev}{%
\section{Ontology-Driven Development}\label{ontology-driven-dev}}

The growing demand for more complete, formalized, and precise models has
led to a new trend in \gls{mdd}. This trend
involves integrating ontologies as formal models into software
applications \autocite{Haav2018}. Since then, ontology-driven techniques
have gained attention in both academia and industry as a method for
designing software artifacts as well as decision support systems.

Ontologies are the fundamental cornerstone of the Semantic Web, which was
proposed by Tim Berners-Lee in 2000 to resolve interoperability
issues by adding an extension to the current web. The Semantic Web
provides well-defined machine-readable information in a way that computers
can comprehend the meaning of information on the web and better process it
\autocite{Kalou2013}. The Semantic Web plays a key role in realizing the vision of \gls{hci} to enable human and machine communications by providing the missing component: the involvement of machines. The
first step toward achieving seamless machine interaction is to
understand the content and meaning of information on the web
\autocite{Berners-Lee1998}. This challenge was addressed through ontology notation.

According to W3C, an ontology is defined as an explicit knowledge
specification using entities, concepts, and their interactions,
typically represented in a hierarchy of terms and relationships.
Ontologies are formally specified by \gls{owl} and \gls{rdf} \autocite{Ponce2022}.

Leveraging ontologies across various phases of software development
offers significant advantages. From requirement analysis, where
ontologies construct a requirement model, to subsequent development
phases, ontologies enhance component discovery and tool
interoperability by leveraging semantic descriptions and domain
models. Moreover, ontology-based development has proven to be suitable for
rapid development applications \autocite{Happel2006}. Depending on
the level of abstraction and the phase in which ontologies are applied,
ontology-driven approaches can be classified into \gls{odd} and \gls{oba}. The former
involves using ontologies during the development phase as a \gls{conceptual
model}, whereas the latter refers to leveraging ontologies during runtime
as application logic artifacts \autocite{DeFreitas2022}.

From a \gls{dss} perspective, the flexibility and level of reuse offered by
ontologies, along with their characteristics of interoperability and
knowledge sharing, make them popular choices \autocite{Hamrouni2021}. The core benefit of developing ontology-based \gls{dss}s lies in
providing problem-solving expertise through the extensive domain
knowledge offered by ontologies \autocite{DeAzevedoJacyntho2021}. The adoption of ontologies in supporting the decision-making process is
widely studied in academic literature. The following table summarizes
some of the state-of-the-art research in various domains such as \gls{bi}, \gls{gis}, and Health.

\hypertarget{tbl:ontology-dss}{}
\begin{longtable}{@{}p{0.33\linewidth} p{0.18\linewidth} p{0.49\linewidth}@{}}
\caption{\label{tbl:ontology-dss} Ontology-based Decision Support Applications}\tabularnewline
\toprule
\textbf{Paper} & \textbf{Domain} & \textbf{Technique} \\
\midrule
\endfirsthead

\toprule
\textbf{Paper} & \textbf{Domain} & \textbf{Technique} \\
\midrule
\endhead

\bottomrule
\endlastfoot

Intelligent \gls{dss} for Business Model  \autocite{Hamrouni2021} & BI &
Case-based reasoning for Business model development. \\

DSS for health tourism  \autocite{Spoladore2023}& Health & \\

Intelligent \gls{dss} for IoT-based smart healthcare \autocite{Saha2021}& Health, IoT & 
Rule-engine, semantic indexing \\

DSS for enterprise interoperability \autocite{Zouch2018} & BI &
Rule-engine, developing an Ontology for Enterprise Interoperability \\

Web-based \gls{dss} for \gls{gis} application \autocite{Vahidnia2023} & GIS &
Knowledge Inference based on GIS ontology \\

\end{longtable}


The studies mentioned above focus on leveraging domain ontologies at the architecture level for business rule extraction or knowledge inference. However, none of the reviewed studies address situational decision-making for non-technical domain experts. They all assume a certain level of expertise in semantic web technologies and are not suitable for situational applications where minimal development time and effort is required.
Such problems could be alleviated by integrating ontologies with \gls{eud} approaches. Considering mashup solutions, ontology integration occurs at various levels: 

At \textbf{data integration}, ontologies are mainly used to reconcile
the semantic heterogeneity caused by heterogeneous data schemas or
facilitate the mapping between different elements in various data
schemas \autocite{Daniel2014a}. \autocite{Sanctorum2022} introduced an ontology-based \gls{eud} approach to construct and
consume a domain-specific knowledge base. In this approach, the domain
ontology generation is performed manually by domain experts.
Additionally, a development toolkit is provided to set up the knowledge
base and fill it with domain data. However, this method may not be
suitable for large ontologies as it requires significant effort from domain
experts. To further facilitate data integration, some studies have
proposed methods to assist domain experts in annotating data. In
\autocite{Kawamoto2006}, \gls{rdf} templates are provided for end-users
to generate semantic descriptions for their knowledge domain. Despite
the simplicity offered by templates, domain experts do not have the
expertise to modify them. The ontology-based approach can be combined with
\gls{eud} techniques. For instance, \autocite{Dorodnykh2021} proposed a
model-driven approach for onboard aircraft troubleshooting using visual
programming.

During \textbf{component discovery}, ontology-based approaches can
enhance the search technique and retrieve semantically
similar services based on the end-user's input. Typically, in such
methods, the services and input queries are semantically analyzed based
on the domain ontology, and similar services are retrieved by
performing logical reasoning \autocite{Zhang2018}. Approaches
such as \autocite{Soylu2017, Zarei2018, Arunachalam2013, Arunachalam2013} introduced
ontology-based query formulation and a goal-oriented method for a more
informed search technique and query formulation.

At the \textbf{composition} level, domain and task ontologies are
used to expand the user's intention and deduce the most suitable
composition logic. Ontologies can better capture the desired service
functionalities to address user goals \autocite{Xiao2011}. An
example of this category of solutions is presented in \autocite{Kim2016} as an ontology-based Open \gls{api} composition mashup and in
\autocite{Debnath2022} for supporting \gls{iot} end-users with a
Trigger-Action ontology.



\hypertarget{sec:sota.assessment}{%
\section{Result Assessment}\label{sec:sota.assessment}}

In previous sections, the main approaches for developing a domain-specific situational application have been reviewed. In this section, we thoroughly evaluate these approaches against our defined process and tool requirements.
\gls{mdd}-based approaches offer reusability and productivity during the design phase. Models are customized to meet the system requirements and therefore provide advantages such as adaptability and efficiency in domain-specific scenarios. The ability to describe systems in a platform and implementation-independent manner enhances interoperability. However, not all the \gls{pim} offer the same level of abstraction. Domain experts’ involvement in prototyping and model development is noted to be minimal. Most approaches only involve domain experts as actors during the requirement analysis phase due to their limited expertise and knowledge in \gls{mdd}.
Composition tools facilitate application development and maintenance by eliminating the detailed models. These tools typically enable end-users to select suitable components from a dedicated repository. However, the composition logic is regulated by the composition model. From the \gls{ui} perspective, the composition tools may provide visual aids and controlled natural language to lower the learning burden for domain experts. While certain composition tools offer semi-automated component discovery or complete composition, the overall development process still requires manual effort. 
Ontology-driven techniques are applied during the development time or run time and increase the semantic interoperability while integrating data from various data sources. For knowledge-intensive applications, such as \gls{dss}s, ontological approaches provide superior adaptability to user requirements by effectively structuring and organizing domain knowledge (De Freitas et al., 2022). Such techniques effectively understand the user’s query and minimize the gap between the user’s intention and the provided solution while providing sufficient level of domain specificity. However, the generation, integration, and management of ontologies require specific expertise that domain experts do not possess. For complex domains, the run time reasoning for querying the ontologies may impair the application performance.
\gls{iot} offers lightweight, user-centric solutions that result in higher usability and increased end-user involvement. It enables rapid prototyping, allowing users to quickly develop situational applications to address their needs, thereby reducing the required development cost and effort. \gls{iot} processes also encourage the reuse of existing software artifacts, further speeding up the development process.



\hypertarget{sec:sota.discussion}{%
\section{Analysis of Assessment Results}\label{sec:sota.discussion}}
\vspace{15pt}

According to the assessment presented in XX, no comprehensive approach exists to satisfy all the defined requirements and thus enable domain experts to effectively develop a domain-specific situational application. 
The solutions categorized under \gls{eud} category, achieve the best results in terms of usability, effectiveness, and the systematic reuse of existing components, although the final solution’s reusability remains relatively low. The Functionality integration (PR3), Interactive user interface (\cref{ro:2}), and Domain Specificity (\cref{ro:3}) requirements are determined by the underlying technique, which holds true for both \gls{eud} and composition tools. Composition tools exhibits the highest reuse level and require less development time and effort, yet they may not be suitable for non-technical domain experts, a limitation shared with \gls{mdd} approaches. Ontology-based solutions efficiently address the Domain Specificity (\cref{ro:3}) requirement but may involve time-consuming configuration steps and require a certain technical proficiency. 
The mentioned shortcomings prove the inadequacy of reviewed techniques to solely address the requirements of domain experts in situational decision-making. To fully address the problems identified in this thesis a comprehensive approach is required which combines the advantages of each mentioned category. Considering the mentioned advantages and limitations, and aligning with the established objectives, web mashups emerged as the most suitable candidates for domain-specific situational applications.

\hypertarget{tbl:assessment-summary}{}
\begin{longtable}{@{}p{0.35\linewidth}cccc@{}}
\caption{\label{tbl:assessment-summary}Assessment Summary of State-of-the-Art Approaches}\tabularnewline
\toprule
\textbf{Requirements} & \rotatebox{90}{\textbf{EUD}} & 
\rotatebox{90}{\textbf{Ontology-based}} & 
\rotatebox{90}{\textbf{\gls{mdd}}} & 
\rotatebox{90}{\textbf{Composition Tools}} \tabularnewline
\midrule
\endfirsthead

\toprule
\textbf{Requirements} & \rotatebox{90}{\textbf{EUD}} & 
\rotatebox{90}{\textbf{Ontology-based}} & 
\rotatebox{90}{\textbf{\gls{mdd}}} & 
\rotatebox{90}{\textbf{Composition Tools}} \tabularnewline
\midrule
\endhead

\bottomrule
\endlastfoot

Semi-Automation & x & x & - & xx \tabularnewline
Systematic Reuse & xx & x & x & xx\tabularnewline
Functionality Integration & - & - & x & xx \tabularnewline
Interactive User Interface & - & - & - & - \tabularnewline
Domain Specificity & - & xx & x & - \tabularnewline
Usability & xx & - & - & x\tabularnewline
Effectiveness & xx & x & x & xx \tabularnewline

\end{longtable}

\vspace{-15pt}
\hypertarget{sec:sota.summary}{%
\section{Summary}\label{sec:sota.summary}}
\vspace{15pt}

This chapter provided a comprehensive review of existing approaches and technologies for situational decision-support tools. The approaches were selected in alignment with the thesis objectives and assessed based on the defined requirements in \cref{sec:requirements-analysis}. The first reviewed category was \gls{eud} solutions, which can be studied according to the application domain, the programming technique, and the user’s domain. Each programming technique was assessed based on the degree to which they provide usability and expressive power. Other reviewed approaches are Web Composition tools, Ontology-based development, and Model-Driven development. The assessment provided in this chapter revealed the lack of a holistic solution that provides an interactive, domain-specific reuse-oriented, and easy-to-use mechanism. These findings will serve as a foundation for designing the solution concept.
